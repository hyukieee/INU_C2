#  1차원 배열과 문자열, 다차원 배열 ,포인터
## 배열 
* 자료형 array
	- C언어에서의 derived data types 중 하나.
		- Derived data type
			- Fundamental data type(int, char, float, ...)을 이용해서 만들어 지는 자료형
* Array는 index가 붙어 있는 자료형
	- int a[10];
		- a[0], a[1]... a[9]
		- 배열의 첨자는 0부터 시작된다.
* 변수의 종류에 관계없이 낮은번지에서 높은 번지로 문자가 저장된다. 
	- 일반 변수들은 보통 먼저 정의된 변수가 높은 번지에 만들어지고, 다음 정의된 변수가 낮은 번지에 만들어짐 
		- 예시로 int a,b =0;으로 한다면 a는 상대번지 163에, b는 151에 만들어져 있다.
	- 하지만, 배열은 반드시 시작점부터 데이터 크기 만큼 증가하여 순서대로 만들어진다.
* 다른 일반 변수들은 보통 먼저 정의된 변수가 높은 번지에 만들어지고, 다음 정의된 변수가 낮은 번지에 만들어진다.
   - 예를들어, 위 그림에서, a는 상대번지 163에, b는 151에 만들어져 있다.  
* 그러나 배열은 반드시 시작점부터 데이터크기만큼 증가하여, 순서대로 만들어진다.   
   - 예를들어, char x 배열은 상대번지 0부터 시작하고 하나씩 증가하는 번지를 가진다.  
  x[0]는 상대 0번지, x[1]은 상대 1번지, x[2]는 상대 2번지 등

### 배열의 종류
* ﻿﻿모든 데이터 형을 배열로 만들 수 있다.
* ﻿﻿포인터도 배열의 데이터가 될 수 있다.
* ﻿﻿일정한 형태의 데이터가 같은 크기로 계속 반복되어 "연속"으로 저장된다.
* ﻿﻿그 중 char 문자는 문장"이라는 특별함 때문에 문자열" 이라 고 한다. 연속으로 출력되는 등의 처리를 할 수 있기 때문에 다른 배열과 달리 주의를 기울여야 한다.

### 배열의 초기화 기본
* ﻿﻿float f[3] = {0.0, 1.7, -9.7};
* ﻿﻿int a[100] = {1};
- ﻿﻿a[0]=1로 그 이후의 원소는 모두 0이 된다.
* ﻿﻿초기화 시키는 상수의 개수가 배열의 크기보다 적으면 이후의 원소들은 모두 0으로 초기화
* ﻿﻿int a[] = {1, 2}; = int a[2] = {1, 2};


## 문자열(string)
* 문자열
  - ﻿﻿"I am a boy", "String", **(Null string), ...
    - ﻿﻿NULL string은 비어 있는 문자열이라고 생각하면 된다.
    - ﻿﻿문자열에 NULL (값 0) 만 있다는 뜻이다.
    - ﻿﻿NULL 은 문자열의 끝을 나타내며, 문자열은 반드시 NULL로 끝나야 만 한다. (문자열은 printf0 등의 함수에서 연속으로 출력될 수도 있 으므로 끝을 지정하지 않으면 끝낼 수가 없게된다.)
- ﻿﻿문자열은 문자(character)의 집합이다.

### 문자열은 메모리에 어떻게 저장 되는가?
* ﻿﻿"I am a boy"
* ﻿﻿문자열"lam a boy"는 메모리 에 오른쪽 그림과 같은 형태로 존재한다.
- ﻿﻿'I', '', 'a' 등은 문자(char)이다.
- ﻿﻿"\0"은 문자열의 끝을 나타 내는 특수문자 이다. NULL
* ﻿﻿변수의 종류에 관계없이 낮은 번지에서 높은 번지로 문자가 저장된다
  ```
  1000 'I'
  1001 ' '
  1002 'a'
  1003 'm'
  ...
  1010 '.'
  1011 '\0'
  ```
### 문자열과 배열
* ﻿﻿문자열은 문자의 집합이므로 char의 배열(array)로 문자열을 나타낼 수 있다.
* ﻿﻿char tmpstr[12];
  - ﻿﻿tmpstr은 문자형(char) 변수 12개의 배열이다.
  - ﻿﻿따라서 tmpstr은 문자(character) 12개를 저장할 수 있다.
  - ﻿﻿12개에는 Null 문자도 반드시 포함되어야 한다. (즉, 실제 문자는 11개)
  - ﻿﻿인덱스 번호는 0 부터 시작한다
* ﻿"I am a boy"와 같은 문자열은 char array 변수tmpstr에 저장될 수 있다.
  - ﻿﻿tmpstr［0］='I'
  - ﻿﻿tmpstr[1] = ' '
  - ...
  - ﻿﻿tmpstr［10］= '.'
  - ﻿﻿tmpstr[11] = '\0'
* ﻿﻿I am a boy. 11문자와 특수문자 '\O'까지 저장해 야 하므로 12개의 원소를 가지는 배열이 필요하다.

### 변수와 메모리
```
int nmain() {
int a=0;
int b=0;

return 0;
}
```
각각의 변수는 연속된 메모리에 저장된다는 보장이 전혀 없다.
- ﻿﻿실행되는 순간 운영체제의 상황 (혹은 시스템 상황)에 따라 위치는 달라진다.
- ﻿﻿배열은 반드시 연속적으로 저장된다

---
## 1차원 배열에서의 주소와 그 표현
  *   1차원 char 배열의 주소와 표현
*   1차원 int 배열의 주소와 표현
*   나머지 type에 대해서는 각자 같은 방식으로 확인해 보세요.  
  
  
* ﻿﻿char a[12] ="I am a boy" : // 혹은 =('I', 'a', 'm', .... } 처럼 써도됨
* ﻿﻿첫번째 문자의 주소가 1000 일 때, 다음과 같다. (다음과 같이 표현한다)
* ﻿﻿a는 1000 이다. (주소, 상수)
* ﻿﻿a는 포인터상수 이다.(변경불가, 할당받음)
* a﻿﻿[0] 은 'I' 이다. (char 변수)
* ﻿﻿a이 부터 a11] 까지 각 char는 변수이다.
* ﻿&a[0]은 a[0] 문자의 주소인 상수이다.
* ﻿&a[0]은 a와 같다.
• 배열의 이름(여기서는 a)은 첫번째 덩어리의 주소를 나타낸다.
 ```
(10진수)
  1000 'I'
  1001 ' '
  1002 'a'
  1003 'm'
  ...
  1010 '.'
  1011 '\0'
  ```

### 실제값과 유의사항
```
int main(){
  char addr,a[12] = "I am a boy.";
  printf("%p\n",a);
  printf("%p\n",&a[0]);
  printf("%c\n",a[0]);
  printf("%d\n",&a[2]-&a[0]);

return 0;
}
```
* ﻿﻿a 와 &a[0]이 의 값이 같음을 알 수 있다.
* ﻿﻿a[0]는 char 값을 나타낸다는 것을 알 수 있다. ('I')
* ﻿﻿주소의 차이는 계산해서 구할 수 있으나, ( 그 결과 2에 대해서는 뒤에서 다시 체크해 보자. 앞시간 참조)
* ﻿﻿주소끼리의 합은 연산할 수 없다. !!!!
* ﻿﻿그래서 &a[2] + &a[0] 은 구할 수 없다. 허용되지 않는다.

### 참고!!!
* ﻿﻿char a[12] ="I am a boy" ; 에서 실제로 컴퓨터가 하는 일
* ﻿﻿문자열을 제외하고는 이런 식으로 배열 값을 할당 하는 경우는 없다. 문자 열이 특별한 경우
* ﻿﻿프로그램에서 " " 로 표현되는 문자열이 있으면 텍스트 영역(코드와 같은 정 해진 상수값들을 저장하는 영역)에 일단 문자열을 저장하고,
* ﻿﻿char 배열인 변수공간에 그 문자열을 다시 복사 해 놓는다.
* ﻿﻿그리고, 그 문자열의 첫번째 위치를 a 로 나타낸다.
* ﻿﻿컴파일러는 모든 변수 이름을 상대 주소로 바꾸어 처리한다. 변수명은 없어 진다. 따라서 이 과정에서 char, int 등 모든 크기에 맞는 주소계산이 이루어 진다.
* ﻿﻿실제 컴퓨터는 a 라는 것은 모르고 실제 할당된 주소로 계산 & 처리한다.

### 상수인 것과 변수인 것
* ﻿﻿char a[12] = "I am a boy" ; 에서
* a[0]~a[11] 까지 모든 Char 값은 변수이다.즉, 문자값을 모두 변경할 수 있다.
* ﻿﻿a 및, &a[0]이 ~ &a[11] 의 모든 주소는 상수이다. 즉, 주소값은 할당받는 것이지, 임의로 변경할 수는 없다.
* 
  ### 1차원 int 배열의 주소와 표현
* ﻿﻿char i[12] = {100, 200, 300, 400, 500,}
* ﻿﻿첫번째 숫자의 주소가 1000 일 때, 다음과 같다. (다음과 같이 표현한다)
* ﻿﻿i는 1000 이다. (주소, 상수)
* ﻿i는 포인터상수 이다.(변경불가, 할당받음)
* ﻿﻿i[0] 은 100 이다. (int 변수)
* ﻿i[0] 부터 i[11] 까지 각 int는 변수이다.
* ﻿&i[0]은 i이 숫자의 주소인 상수이다.
* ﻿﻿&i[0]은 와 같다.
• 배열의 이름(여기서는 i)은 첫번째 덩어리의 주소를 나타낸다.
```
1000 100
1004 200
1008 300
1012 400
1016 500
1020 0
1024 0
...
1044 0
```
### 실제 값과 유의 사항
```
int main(){
  int diff,i[12] = "{100,200,300,400,500,};
  printf("%p\n",i);
  printf("%p\n",&i[0]);
  printf("%c\n",i[0]);
  printf("%d\n",&i[2]-&i[0]);

return 0;
}
```
i와&i이 의 값이 같음을 알 수 있다
* ﻿﻿i[0]는 int 값을 나타낸다는 것을 알 수 있다. ( 100)
* ﻿﻿주소의 차이는 계산해서 구할 수 있으나,
* ﻿﻿주소끼리의 합은 연산할 수 없다.
* ﻿﻿그래서 &i[2] +&i[0] 은 구할 수 없다. 허용되지 않는다


### 참고!!
* ﻿﻿Char c[12] 와 int i[12] 에 대해서
* ﻿﻿&c[2] -&c[0] 와 &i[2] -&i[0] 은 모두 값이 2 이다.
* ﻿﻿각각 2와 8이 아님에 유의해야 한다.
* ﻿﻿앞시간에 이야기 했듯이, 주소값의 +-는 다음", "이전" 의 의미이다.
* ﻿﻿따라서 위에서 두 주소의 - 연산은 그 사이에 char 또는 int 가 각각 몇 개 들 어가는 공간인지를 구하는 것이다.
* ﻿﻿참고로 2l의 주소와 이의 주소의 실제 메모리 차이, 즉 8을 구하려면 그럼 어떻게 연산해야 하겠는가?
* ﻿﻿각각을 주소가 아닌 숫자로 생각하고 연산해야 하므로 다음과 같이 해야 한다 --> (int) &i[2] -(int) &i[0]

  ---

  
