# 포인터

중간고사 적극 반영 x BUT 함수를 쓰려면 포인터가 필요함
포인터 변수는 메모리의 번지(주소)를 저장하는데 쓰이는 변수이다.
앞의 예제들에서 봤던 1004, 1008같은 주소를 저장하고, 이를 처리할 수 있는 (읽고, 값 바꾸기 등) 것이 포인터 변수이다. 
포인터 변수가 저장하고 있던 값을 바꾼다는 것은 가리키는 메모리 위치를 변경한다는 의미
컴퓨터에서 모든 데이터는 바이트 단위로 주소를 가지고 있다.따라서 저장되는 주소는 바이트의 주소이다.
그러나 주소로부터 1,2,4,8바이트 등이 하나의 데이터 일 수 있다. 그것을 구분해 주는 것이 포인터 변수의 형(TYPE 즉, char, short,int 등 )이다.

# 포인터 변수는 왜 필요한가?
프로그램에는 데이터가 반드시 필요하고, 그 데이터는 값이 정해진것이 아니라 필요에 따라 값을 변경하여 저장함
데이터를 필요애 따라 가리키고 변경하는 등 처리를 할 필요성이 있다.

예를 들어

```
#include<stdio.h>
int main() {
	unsigned short int i[3] = { 0x1234,0x5678,0xABCD };
	//라는 데이터가 있다고 하자
	//메모리 값은 다음과 같다.
	// 0x34 0x12 0x78 0x56 0xCD 0xAB
  /*
	이때 unsigned char포인터 p가 0x12의 바이트를 가리킨다고 생각해보자 
	p가 가리키는 위치에 따라 바이트 값을 읽을 수 있다.
	
	같은 방법으로 insigned short int 포인터 pi가 역시 같은 0x12 바이트를 가리키게 할 수 도 있다. 
	이떄는 전혀 새로운 값을 pi가 읽게 된다. (0x12 + 0x78 결합 = 0x7812)

	메모리에 값이 있으면 포인터는 원하는 형태로 값을 읽을 수 있다.

	0xCD567812의 unsigned int 값도 읽을 수 있다.. (저장 & 읽기)*/
```


# 포인터 변수

## 포인터 변수의 선언 
-일반 변수의 선언과 같으나 변수 앞이 *를 붙이다. (*는 한개 이상 붙일수 있다.)

int *p; 정수형 변수의 주소에 대한 포인터 변수 선언
		(int*)p  or int (*p)로 생각하자

char *p; 문자형 변수의 주소에 대한 포인터 변수 선언

변수의 타입에 따라 별개의 포인터 변수를 사용해야 한다.
	- 정수 변수의 주소를 저장하는 정수 포인터 변수(int *)
	- 실수 변수의 주소를 저장하는 실수 포인터 변수(float *)

p, &p, *p를 정확하게 구분할 것
p : 주소를 가리킴
*p : 포인터가 가리키는 주소 안에 있는 값
&p :p의 주소


포인터 변수는 각 데이터 타입 별로 있다. (정수 포인터, 문자 포인터)

	- 각 데이터 타입의 크기가 다르기 떄문ㅇ
		데이터 타입의 크기에 따라 메모리에서 차지하는 영역이 다르다.
		struct 처럼 사용자가 지정한 임의의 크기를 갖는 메모리도 포인터로 가리키며 연산 가능
	
	- 포인터 관련해서 코딩할 때 주의 할 것은 해당 포인터가 정확히 무엇을(어디서 어디까지를 , 혹은 몇 바이트를) 가리키는지 알아야한다.
	그래야 +, - 연산을 정확히 할 수 있음
	- 메모리를 가리킴으로써 생기는 다양한 효과를 이해해야함



# 포인터 변수의 초기화 
int *p, i;
-정수 포인터 변수 p와 정수 변수 i의 선언
p = 0;
-p에 0번지를 넣는다.
p = NULL;
-여기서 NULL은 0번지와 같다.
p = &i;
-p에 i의 주소(번지)값을 넣는다.
p = (int *) 1776;
-p에 정수상수 1776을 정수포인터로 변환한 값을 넣는다.


# & Operator
&연산자는 변수의 주소(번지)를 돌려주는 연산자이다.
-&p : 변수 p의 주소이다
scanf(“%d”, &p)
-scanf의 인자는 control_string(%d)과 변수주소(&p)이다.


# Type Casts 
// 그 순간에만 casting 된 타입으로 판단한다. 
- 포인터에서 데이터의 단위크기가 중요함을 생각해보기 위해 type cast를 다시 생각해보자.
- 우선, type cast 연산자는
	- 데이터타입을 변환해주는 연산자
	- (float) i  <- 이런식으로 사용된다(여기서 i는 int 변수라고 생각하자)
- 그러면 위의 수식은 i의 값을 가지는 실수로 변환된다. 즉 i에 3이라는 값이 들어있으면 (float) i는 3.0 의 값을 가지게 된다.

	- C프로그램은 여러 개의 연산자가 혼합되어 사용된다. 그러나 모든 연산자는 우선순위에 따라 순서대로 처리된다. 따라서 type cast가 발생하는
	  시점을 명확히 이해해야 값의 처리가 정확해진다. (예제 1-1)


*/
```
//예제 1-1
#if 0
#include<stdio.h>

#define STUDENT_NUM 6 //값 변경 불가
int main() {
	int sn = STUDENT_NUM;
	int total_score = 39;
	float avr_score;

	avr_score = total_score / sn; // 값은 얼마일까? 이유는?
	//int % int 는 버림이 발생 

	printf("Anerage score is %.2f", avr_score);
	// 실수형으로 프린트 하더라도 6.00으로 나옴


	return 0;
}
#endif
```
```
/**/
//예제 1-2
#if 0
#include<stdio.h>
#define STUDENT_NUM 6
int main() {
	int sn = STUDENT_NUM;
	int total_score = 39;
	float avr_score;

	avr_score =(float) total_score / (float)sn; // 값은 얼마일까? 이유는?


	printf("Anerage score is %.2f", avr_score);

	return 0;
}
//하나의 데이터가 있다해도, 이것을 바라보는 크기에 따라 값의 해석은 완전히 달라진다. 
// 포인터는 가리키는 역할이다.
// 얼마의 크기를 가리키는 포인터인가는 무척 중요한 것이다.
#endif

```

# 배열과 포인터의 관계
 - int a[100];
	- 위의 선언은 a[0],a[1], … ,a[99]의 정수 100개의 배열에 대한 선언이다.
	- 앞에서 공부한 대로, 위의 a는 주소(포인터)이며 배열의 첫 번째 원소 a[0]의 주소를 나타낸다.
	(우리는 a가 첫번째 “큰 덩어리”의 주소라고 기억하자) !!!!!!!!

	- 위에서 만들어지는 100개는 int 형이다.
	- a는 주소이며, 상수이다. 즉, 연속 100개의 int 형이 만들어지는 시작 주소를 할당받은 주소이다.
	- a[0],a[1]…의 형태는 모두 int 형태의 변수이다.
	- a[100]도 값을 읽을 수 있다. C언어에서 못하게 제한하지 않는다.
	그러나 a는 a[0]~a[99]까지의 100개만 유의미하게 관리하며, a[100]의 위치는 접근할 수는 있게 해 주지만, 그 값에 대해서는 책임지지 않는다.


	- 배열로 선언된 a[0]~a[99]까지의 100개의 공간은 보호되어 의도적으로 바꾸지 안는 한 다른 것으로 덮어 씌어지지 않지만, 
	  a[100]은 값은 읽을 수 있지만, 언제든 덮어 씌어질 수 있다.[민혁]

 # 간단한 실험 
 
 a,b,c,를 각 int 10개의 배욜로 만들었다.
4*10 바이트 할당
a = 0번지
b = 48번지
c = 96번지
왜 0,40,80번지가 아니지??
-> 각 8개씩 떨어져있다.

```
#if 0
#include<stdio.h>
int main() {
	int sn = SN
		int tS = 39, c[10] = { 1000.2000,3000, }, a[10] = { 1,2,3,4,5,6,7,8,9,10 }, b[10] = { 100,200,300, };


	// c [0]  [1]   [2] [3] [4] [5] [6] [7] [8] [9] [쓰레기] [쓰레기] b[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [쓰레기] [쓰레기] a[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [쓰레기] [쓰레기]
	//  1000 2000  3000  0   0   0   0   0   0   0      ?        ?	  100 200 300  0   0   0   0   0   0   0      ?       ?       1   2   3   4   5   6   7   8   9   10      ?         ?
	
	// - 저 쓰레기 두개의 값은 언제든지 바뀔수있다.
		//- 만약 printf(“ % d”, b[14])를 한다면 ? ? ?   >3
		// a[-3] == b[9]
		// b[12] == a[0]
float avg_score

	return 0;
}
#endif
```

# iptr로 할 수 있는 일
-*iptr는 a[0]이다.
-정확하게 a[0]은 *(iptr + 0)을 의미한다.
* C언어에서 []은 연산자이다.
* []는 *( + )와 완전히 동일한 의미이다.
* 여기서 +는 더하기가 아니라 “다음”의 의미이다.
* 컴퓨터는 “다음”이 없으므로, 각 크기를 더해서 더할 숫자를 미리 정한다.
-iptr+1의 값은?
* a[0]의 다음 원소인 a[1]의 주소이다. 이 다음을 명확하게 알기 위해 가리키는 곳의 크기가 중요한 것이다.
* iptr은 int pointer이기 때문에 iptr + 1은 1001이 아니라 정수 크기에 맞춰 계산된다(이 경우는 1004)
* 따라서 *(iptr +1)은 a[1]이다.

iptr은 1000이라는 값을 가지며 iptr이 a[0]을 가리킨다고 생각해도 좋다. 
a는 1000이라는 값을 가지는 포인터 상수이다. 


//1000번지  a[0]
  1004번지  a[1]
  1008번지  a[2]

  ... 

  1396번지  a[99]


  어디를 가리키는 가가 아니라 가리키는 곳부터 몇바이트 인지가 중요함

a[3] 
= *(a+3)
= *(3+a)
=3[a]

a[-3]
= *(a-3)
= *(3-a)
=(-3)[a]
